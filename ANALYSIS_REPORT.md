# Отчет по анализу кодовой базы OpsPilot Backend

## 1. Перформанс (Performance)

### Наблюдения:
*   **NATS Consumers**: В `internal/ingest/events.go` используется `PullSubscribe` с `Fetch(10)`. При высоком потоке событий это может стать узким местом. Рекомендуется увеличить размер пакета или использовать адаптивный Fetch.
*   **Отсутствие кэширования**: Каждое событие или heartbeat вызывает запрос к базе данных (`GetAgentByAgentID`). При большом количестве агентов база данных будет перегружена избыточными SELECT-запросами.
*   **Эффективность сериализации**: Использование `msgpack` для передачи данных между агентом и бэкендом — отличное решение. Однако внутри бэкенда происходит частое перекодирование из `msgpack` в `JSON` для хранения в DB (поле `meta`, `context`), что создает дополнительную нагрузку на CPU.
*   **Отсутствие тестов**: В проекте полностью отсутствуют unit- и integration-тесты. Это затрудняет проверку производительности и стабильности при внесении изменений.

### Рекомендации:
*   Внедрить кэширование метаданных агентов (например, в Redis или in-memory LRU кэш).
*   Оптимизировать параметры потребления NATS (Batch size, AckWait).

---

## 2. Потребление ресурсов (Resource Consumption)

### Наблюдения:
*   **Нагрузка на БД от Heartbeats**: В `internal/ingest/kv.go` каждый heartbeat (каждые 60 сек от каждого агента) вызывает `CreateAgent`, который выполняет `INSERT ... ON CONFLICT DO UPDATE`. Это создает постоянную write-нагрузку на PostgreSQL.
*   **Периодические задачи**: `reconcileLoop` в `KVWatcher` запускается каждую минуту для пометки старых агентов как offline. При росте количества агентов этот запрос может замедляться.
*   **Логирование**: Обильное использование `log.Printf` и `fmt.Printf` (в AI сервисе) без уровней логирования может привести к переполнению диска логами при высокой нагрузке.

### Рекомендации:
*   Обновлять `last_seen_at` в БД не на каждый heartbeat, а с некоторой задержкой (например, раз в 5 минут) или использовать "warm storage" для статусов.
*   Перейти на структурированное логирование (например, `slog` или `zap`).

---

## 3. Безопасность (Security)

### Наблюдения:
*   **Аутентификация (API vs Swagger)**: В `internal/auth/middleware.go` проверка идет только по Cookie. При этом в Swagger-документации указано использование `Authorization: Bearer <token>`. Это серьезное расхождение: внешние API-клиенты не смогут авторизоваться через заголовок.
*   **CSRF**: Использование cookie-based аутентификации без CSRF-токенов делает веб-интерфейс уязвимым к Cross-Site Request Forgery.
*   **Секреты**: В `internal/auth/jwt.go` секрет `JWT_SECRET` берется из env. Если он не задан, ошибка возвращается только при попытке вызова, а не при старте приложения.
*   **AI Сервис**: В `internal/services/ai.go` жестко прописан `dummy-key`, если переменная окружения не задана. Это может привести к тому, что в dev/stage среде система будет молча "падать" на фоллбэки.
*   **Публичные эндпоинты**: Эндпоинт `/api/v1/agents/enroll` открыт. Хотя он требует подписи NKey и Bootstrap-токена, отсутствие rate-limiting на нем позволяет проводить brute-force атаки на токены.

### Рекомендации:
*   Добавить поддержку заголовка `Authorization` в middleware.
*   Внедрить rate-limiting для критических эндпоинтов (login, enroll).
*   Валидировать наличие всех необходимых секретов при старте `main.go`.

---

## 4. Дублирование кода и функционала (Code Duplication)

### Наблюдения:
*   **Создание агентов**:
    *   `internal/handlers/handlers.go`: Метод `CreateAgent` (не используется в роутах).
    *   `internal/natsauth/handlers.go`: Метод `CreateAgent` (используется).
    *   `internal/ingest/events.go` и `kv.go` содержат логику создания агента "на лету".
*   **Вспомогательные функции**: `decodeStringArray` и `nullIfEmpty` продублированы в `internal/storage/storage.go` и `internal/storage/organization.go`.
*   **Модели в хендлерах**: В `internal/handlers/handlers.go` в методе `GetAgents` объявлены локальные структуры `agentRow` и `agentResponse`, которые частично дублируют `models.Agent`.
*   **Дублирование пакетов**: Существуют пакеты `internal/auth` и `internal/natsauth`. Хотя они решают разные задачи (пользователи vs агенты), в них много схожего кода для работы с JWT и токенами.

### Рекомендации:
*   Вынести общие утилиты (`nullIfEmpty`, `decodeStringArray`) в отдельный пакет (например, `internal/pkg/utils`).
*   Удалить неиспользуемый код в `internal/handlers/handlers.go`.
*   Унифицировать логику создания/регистрации агента в `internal/storage`.

---

## 5. Расхождения с PROTOCOL.md

### Наблюдения:
*   **Файл отсутствует**: В корне проекта и в папке `docs` отсутствует файл `PROTOCOL.md`, на который ссылается задание. Это критическое расхождение с ожиданиями.
*   **Версионность**: В коде упоминаются структуры `EventV3` и `HeartbeatV3`, что подразумевает наличие описанного протокола третьей версии, однако документации по нему нет.
*   **Пути API**: В `README.md` указан путь `POST /v1/admin/exec`, но в реализации (`handlers.go`) он заменен на `POST /api/v1/agents/{id}/execute`.

### Рекомендации:
*   Создать или восстановить `PROTOCOL.md`.
*   Актуализировать `README.md` в соответствии с реальными путями API.
